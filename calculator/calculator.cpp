//Создать приложение для вычисления значения арифметического выражения, которое
//сожет включать в себя действительные числа, а также круглые скобки и следующие 
//операции +,-,*,/,^ (возведение в степень). Вычисления должны производится 
//с учетом скобок и приоритетов используемых операций. Предусмотреть корректную 
//обработку возможных ошибок и информирование о них пользователя.

#include <crtdbg.h>
#define _CRTDBG_MAP_ALLOC
#define new new( _NORMAL_BLOCK, __FILE__, __LINE__)

#include <iostream>
#include <windows.h>
using namespace std;

int priority(char); //функция определения приоритета оператора
double calculate(char*, int, int, int&); //рекурсивная функция для вычисления всего выражения
double calcOper(double, char, double, int&); //функция арифметического вычисления двух чисел

int main() {
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);
	char str[100]; //строка в которую будем вводить задание для вычисления
	int sizeStr = 0; //переменная размера строки (вводим что б не использовать постоянно strlen(str), экономия процессорного времени)
	bool *errorInPut = new bool; //метка ошибки для организации циклического ввода
	double result = 0;	//переменная для хранения результата вычисления
	int error = 0;	//переменная для фиксации ошибки (1 - деление на ноль, можно добавить другие по необходимости)
	do {
		*errorInPut = 0; //обнуляем вначале каждого повторного ввода (для исключения вечного зацикливания)
		cout << "Введите строку (без пробелов) для вычисления выражения\nМожно использовать действительные числа с разделителем \".\" (точка)," << endl;
		cout << "круглые скобки и следующие операции: +, -, *, /, ^ (возведение в степень)" << endl;
		cin >> str;	//ввод строки с экрана
		int *countBrackets = new int; //счетчик открытых/закрытых скобок (для проверки корректности ввода)
		*countBrackets = 0;	//инициализация "0"
		sizeStr = strlen(str);	//запоминаем длину введенной строки
		for (int i = 0; i < sizeStr; i++) { //запускаем цикл для побуквенной проходки строки
			if (!((*(str + i) >= 48 && *(str + i) <= 57) || priority(*(str + i)) > 0 || *(str + i) == '.')) { //проверка правильности ввода символа (должны быть цифры, точка, скобки и доступные операторы вычисления)
				*errorInPut = 1;	//ставим метку ошибки для возможности повторного ввода с экрана
				cout << "Ошибка ввода: использование неправильного символа в позиции " << i << endl;
				break;
			}
			if (*(str + i) == '(') { //проверка смежных символов от "("
				(*(countBrackets))++; //при нахождении открытой скобки инкрементируем переменную контроля колличества скобок
				if (!(i == 0 || (i > 0 && (priority(*(str + i - 1)) > 1 || *(str + i - 1) == '(')))) { //проверка символа стоящего слева
					*errorInPut = 1;
					cout << "Ошибка ввода: перед \"(\" должен стоять знак оператора или еще одна \"(\" в позиции " << i << endl;
					break;
				}
				if (!(i + 1 < sizeStr && ((*(str + i + 1) >= 48 && *(str + i + 1) <= 57)|| *(str + i + 1)=='('))) {	//проверка символа стоящего справа
					*errorInPut = 1;
					cout << "Ошибка ввода: после \"(\" должна стоять цифра или еще одна \"(\" в позиции " << i << endl;
					break;
				}
			}
			if (*(str + i) == ')') { //проверка смежных символов от ")"
				(*(countBrackets))--; //при нахождении закрытой скобки декрементируем переменную контроля колличества скобок
				if (!(i > 0 && ((*(str + i - 1) >= 48 && *(str + i - 1) <= 57) || *(str + i - 1) == ')'))) { //проверка символа стоящего слева
					*errorInPut = 1;
					cout << "Ошибка ввода: перед \")\" должна стоять цифра или еще одна \")\" в позиции " << i << endl;
					break;
				}
				if (!(i == sizeStr - 1 || (i + 1 < sizeStr && (priority(*(str + i + 1)) > 1 || *(str + i + 1) == ')')))) {	//проверка символа стоящего справа
					*errorInPut = 1;
					cout << "Ошибка ввода: после \")\" должен стоять знак оператора или еще одна \")\" в позиции " << i << endl;
					break;
				}
			}
			if (*(str + i) == '.') { //проверка смежных символов от "."
				if (!(i > 0 && *(str + i - 1) >= 48 && *(str + i - 1) <= 57)) { //проверка символа стоящего слева
					*errorInPut = 1;
					cout << "Ошибка ввода: перед \".\" должна стоять цифра в позиции " << i << endl;
					break;
				}
				if (!(i + 1 < sizeStr && *(str + i + 1) >= 48 && *(str + i + 1) <= 57)) {	//проверка символа стоящего справа
					*errorInPut = 1;
					cout << "Ошибка ввода: после \".\" должна стоять цифра в позиции " << i << endl;
					break;
				}
			}
			if (priority(*(str + i)) > 1) { //проверка смежных символов от знака оператора
				if (!(i > 0 && ((*(str + i - 1) >= 48 && *(str + i - 1) <= 57)) || priority(*(str + i - 1)) == 1)) { //проверка символа стоящего слева
					*errorInPut = 1;
					cout << "Ошибка ввода: перед знаком оператора должна стоять цифра или скобка в позиции " << i << endl;
					break;
				}
				if (!(i + 1 < sizeStr && ((*(str + i + 1) >= 48 && *(str + i + 1) <= 57)) || priority(*(str + i + 1)) == 1)) {	//проверка символа стоящего справа
					*errorInPut = 1;
					cout << "Ошибка ввода: после знака оператора должна стоять цифра или скобка в позиции " << i << endl;
					break;
				}
			}
		}
		if (*countBrackets != 0 && *errorInPut != 1) { //проверка соответствия колличества открывающих и закрывающих скобок, вывод на экран только если нет других ошибок
			*errorInPut = 1;
			cout << "Ошибка ввода: колличество \"(\" не соответствует колличеству \")\"" << endl;
		}
		cout << endl;
		delete countBrackets; //высвобождение динамической памяти
	} while (*errorInPut);
	delete errorInPut;//высвобождение динамической памяти
	//strcpy_s(str, { "(48.1-76.2/(25.7+4.9)+8.6)*21" });	//контрольный пример,  ответ 1138,41
	//strcpy_s(str, { "25+(71.2-56.2+37/2^(2+1))*(18+4)" });  //контрольный пример,  ответ 456,75
	//sizeStr = strlen(str);	//доп.операция для контрольного примера
	result = calculate(str, 0, sizeStr, error); //запуск рекурсии для вычисления
	if (error == 1) cout << "Ошибка вычисления: деление на ноль" << endl;	//вывод ошибки если произошла в процессе вычисления
	else cout << "Результат вычисления выражения:   " << result << endl;	//вывод на экран результата
	}

double calculate(char* str, int startStr, int endStr, int &error) {	//передаем адрес начала строки, начальную позицию в строке, конечную позицию в строке (участок который вычисляем) и переменную для контроля ошибки)
	double number[3] = { 0.0,0.0,0.0 };	//создаем массив для хранения считаных со строки чисел и промежуточных вичисления при проходе строки слева направо (достаточно 3-х поскольку у нас всего 3-х уровневая приоритезация операторов)
	int operation[3] = { 0,0,0 };  //создаем массив для хранения найденых позиций в строке с операторами вычислений при проходе строки слева направо (достаточно 3-х поскольку у нас всего 3-х уровневая приоритезация операторов)
	int numberPos = 0, operationPos = 0; //итераторы для прохода по массивам number и operation
	bool digit = 0;	//метка для поиска начала подстроки с числом (0 - число не обнаружено, 1 - идет уже считывание числа)
	double result;	//переменная для хранения и вывода результата вычислений
	int i;	//итератор для прохода по строке
	for (i = startStr; i < endStr; i++) { //запускаем цикл посимвольного прохода по строке
		if (*(str + i) == '(') { //при нахождении открытой скобки инициализируем поиск всего участка строки входящее в данный скобки для вычисления
			int countBrackets = 1;	//переменная для подсчета колличества скобок: +1 при нахождении открытой скобки, -1 принахождении закрытой скобки
			int start = i + 1;	//запоминам позицию начала строки, исключая текущую "("
			for (i++; i < endStr; i++) { //сдвигаем позицию итератора +1, запускаем подцикл для нахождения конца подстроки с нужной закрывающей скобкой
				if (*(str + i) == '(') { //при нахождении еще одной открывающей скобки игнорируем ее и увеличиваем счетчик скобок
					countBrackets++;
					}
				else if (*(str + i) == ')') { //при нахождении закрывающей скобки декрементируем счетчик скобок
					countBrackets--;
					if (countBrackets == 0) { //если нужная скобка найдена (счетчик равен "0") выходим из цикла
						break;
					}
				}
			}
			number[numberPos] = calculate(str, start, i, error); //записываем в текущую свободную ячейку с числом результат вычислений выражения найденой подстроки со скобками путем запуска еще одной копии данной функции с обновленными параметрами
			if (!numberPos) result = number[numberPos]; //если данное числор первое в массиве тогда записываем в переменную результат (на случай если оно будет единственное на данном участке, без операторов вычисления) 
			numberPos++; //увеличиваем итератор прохода по масиву с записаными числами
		}
		else if (priority(*(str + i)) == 0) { //при нахождении цифры или точки
			if (!digit) { //если метка 0-начало числа
				digit = 1;	//изменяем метку на 1 - число уже найдено
				number[numberPos] = atof(str + i);	//записываем число в массив чисел number
				if (!numberPos) result = number[numberPos]; //если данное числор первое в массиве тогда записываем в переменную результат (на случай если оно будет единственное на данном участке, без операторов вычисления) 
				numberPos++; //увеличиваем итератор прохода по масиву с записаными числами
			}
		}
		else if (priority(*(str + i)) > 1) { //при нахождении оператора вычисления
			digit = 0;	//устанавливаем метку нахождения числа на "0" для возможности нахождения позиции след.числа (числа все разделяються знаками оператора)
			if (operationPos == 0) { //если это первый найденный оператор
				operation[operationPos] = i; //записываем позицию в строке даного оператора в масив operation
				operationPos++; //увеличиваем итератор прохода по масиву с записаными позициями операторов вычисления
			}
			else if (priority(*(str + i)) > priority(*(str + operation[operationPos - 1]))) { //проверяем уровень приоритета найденого оператора, если уровень текущего оператора выше предыдущего, тогда ищем дальше
				operation[operationPos] = i; //записываем позицию в строке даного оператора в масив operation
				operationPos++; //увеличиваем итератор прохода по масиву с записаными позициями операторов вычисления
			}
			else {  //проверяем уровень приоритета найденого оператора, если уровень текущего оператора равен или меньше предыдущего, тогда производим вычисления предыдущих чисел в обратном порядке нахождения
				for (int j = operationPos; j > 0; j--) { //запуск цикла для прохода в обратном порядке найденых чисел и операторов
					result = calcOper(number[j - 1], *(str + operation[j - 1]), number[j], error);	//производим вычисления двух чисел из масива number и берем оператор между ними
					number[j - 1] = result;	//записываем результат вычислений в масив number на позицию левого числа, что б в следущей итерации цикла использовать данные для вычисления
				} //разделяем строку на части по позиции найденого текущего оператора, левую часть мы только что высчитали и записали в result, правую часть запускаем новый экземпляр рекурсивной функции с обновленными параметрами
				result = calcOper(result, *(str + i), calculate(str, i + 1, endStr, error), error); //соединяем обе части путем вычисления с кодом оператора текущей позиции и записываем в result
				if (error > 0) return 0; //если сработала ошибка все обнуляем
				return result;	//возвращаем результат вычислений
			}
		}
	}
	if (operationPos) { //при нахождении конца строки производим аналогичные операции с оставшимся данными в масивах number и operation
		//(в случае когда дальше уже нечего искать и мы не нашли оператор с меньшим или равным приоритетом чем предыдущий) 
		for (int j = operationPos; j > 0; j--) {
			result = calcOper(number[j - 1], *(str + operation[j - 1]), number[j], error);
			number[j - 1] = result;
		}
	}
	if (error > 0) return 0; //если сработала ошибка все обнуляем
	return result; //возвращаем результат вычислений
}

int priority(char symbol) //функция для определения приоритета операций
{
	if (symbol == '(' || symbol == ')')	//если скобки тогда вощвращаем "1" (в данной программе используется только для определения факта наличия скобок)
		return 1;
	//приоритеты операций в след. последовательности от низкого к высокому: 
	else if (symbol == '+' || symbol == '-')	
		return 2;//низкий приоритет операций
	else if (symbol == '*' || symbol == '/')
		return 3;//средний приоритет операций
	else if (symbol == '^')
		return 4;//высокий приоритет операций
	else
		return 0;//если символ цифра или "." возвращаем "0" (в данной программе используется только для определения факта наличия числового выражения)
}

double calcOper(double num1, char operat, double num2, int &error) { //функция произведения вычислений
	switch (operat)
	{
	case '+':
		return num1 + num2;
	case '-':
		return num1 - num2;
	case '*':
		return num1 * num2;
	case '/':
		if (num2 == 0) { //если деление на "0"
			error = 1;	//устанавливаем метку ошибки
			return 0;	//возвращаем "0"
		}
		return num1 / num2;	//или возвращаем результат деления
	case '^':
		return pow(num1, num2);
	}
}